name: code-review-leaderboard-winner

on:
  push:
    paths:
      - '.github/workflows/code-review-leaderboard-winner.yml'
  workflow_dispatch:
  schedule:
    - cron: '0 7 * * 5' # Runs every Friday at 7 AM UTC


concurrency:
  group: code-review-leaderboard-winner
  cancel-in-progress: true

jobs:
  code-review-leaderboard-winner:
    permissions: write-all
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Calculate Last Target Day
        id: calculate-target-day
        uses: actions/github-script@v7
        with:
          script: |
            const now = new Date();
            const targetDay = parseInt("${{ vars.CODE_REVIEW_LEADERBOARD_START_DAY }}", 10) || 5; // Default to Friday (5)
            const targetHour = parseInt("${{ vars.CODE_REVIEW_LEADERBOARD_START_HOUR }}", 10) || 7; // Default to 7:00 AM UTC
            const targetMinute = parseInt("${{ vars.CODE_REVIEW_LEADERBOARD_START_MINUTE }}", 10) || 0; // Default to 0 minutes

            const dayOfWeek = now.getUTCDay();
            const daysSinceTargetDay = (dayOfWeek - targetDay + 7) % 7; // Calculate days since target day
            const lastTargetDay = new Date(now);
            lastTargetDay.setUTCDate(now.getUTCDate() - daysSinceTargetDay);
            lastTargetDay.setUTCHours(targetHour, targetMinute, 0, 0); // Set time to target hour and minute

            core.setOutput('lastTargetDay', lastTargetDay.toISOString());

      - name: Count Reviews
        id: count-reviews
        uses: actions/github-script@v7
        with:
          script: |
            async function getFilteredPullRequests(owner, repo, startDate) {
              const { data: pullRequests } = await github.rest.pulls.list({
                owner,
                repo,
                state: 'all', // Fetch both open and closed pull requests
                per_page: 100,
                sort: 'created', // Sort by creation date
                direction: 'desc', // Newest first
              });

              // Filter pull requests opened or merged within the last week
              const filteredPullRequests = pullRequests.filter(pr => {
                return new Date(pr.created_at) >= startDate || (pr.merged_at && new Date(pr.merged_at) >= startDate);
              });

              const filteredPRs = [];

              for (const pr of filteredPullRequests) {
                // Fetch reviews for each pull request
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner,
                  repo,
                  pull_number: pr.number,
                });

                // Sort reviews by submission date
                reviews.sort((a, b) => new Date(a.submitted_at) - new Date(b.submitted_at));

                // Check if the first review is approved or changes requested
                const firstReview = reviews[0];
                if (firstReview && (firstReview.state === 'APPROVED' || firstReview.state === 'CHANGES_REQUESTED')) {
                  filteredPRs.push({ pr, reviews: [firstReview] });
                }
              }

              return filteredPRs;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const lastTargetDay = new Date(process.env.lastTargetDay); // Use the output from the previous step

            const filteredPRs = await getFilteredPullRequests(owner, repo, lastTargetDay);

            const reviewCounts = filteredPRs.reduce((acc, { reviews }) => {
              reviews.forEach(review => {
                const user = review.user.login;
                if (!acc[user]) {
                  acc[user] = { approve: 0, request_changes: 0 };
                }
                if (review.state === 'APPROVED') {
                  acc[user].approve += 1;
                } else if (review.state === 'CHANGES_REQUESTED') {
                  acc[user].request_changes += 1;
                }
              });
              return acc;
            }, {});

            const sortedReviewCounts = Object.entries(reviewCounts).sort(([, a], [, b]) => {
              const totalA = a.approve + a.request_changes;
              const totalB = b.approve + b.request_changes;
              return totalB - totalA;
            });

            core.setOutput('sortedReviewCounts', JSON.stringify(sortedReviewCounts));
        env:
          lastTargetDay: ${{ steps.calculate-target-day.outputs.lastTargetDay }}

      - name: Get Winner
        id: get-winner
        uses: actions/github-script@v7
        with:
          script: |
            const sortedReviewCountsStr = process.env.sortedReviewCounts;

            if (!sortedReviewCountsStr) {
              throw new Error('sortedReviewCounts is empty or undefined');
            }

            const sortedReviewCounts = JSON.parse(sortedReviewCountsStr);

            let winner = '';
            let winReviews = '';
            // Only show the first place
            if (sortedReviewCounts.length > 0) {
              const [user, counts] = sortedReviewCounts[0];
              const total = counts.approve + counts.request_changes;
              winner = user;
              winReviews = total;
            }

            core.setOutput('winner', winner);
            core.setOutput('winReviews', winReviews);
        env:
          sortedReviewCounts: ${{ steps.count-reviews.outputs.sortedReviewCounts }}

      - name: Send Review Summary to Slack
        if: ${{ steps.get-winner.outputs.winner != '' }}
        uses: slackapi/slack-github-action@v1.26.0
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_NOTIFICATIONS_BOT_TOKEN }}
        with:
          channel-id: ${{ vars.MAIN_SLACK_CHANNEL_ID }}
          payload: |
            {
              "blocks": [
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "ðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠ"
                    }
                  ]
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "Our Code Review Champion of the Week!"
                    }
                  ]
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "ðŸ‘‘ *${{ steps.get-winner.outputs.winner }}* (${{ steps.get-winner.outputs.winReviews }} reviews)"
                    }
                  ]
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "ðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠðŸŽŠ"
                    }
                  ]
                }
              ]
            }
